%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int line_no = 1;
char last_type[20] = "UNKNOWN"; 
int needs_semi = 0; /* NEW: Flag to track missing semicolons */

struct Symbol {
    char name[50];
    char category[20];
    char data_type[20];
    char description[50];
    int first_line;
    struct Symbol *next;
};

struct Symbol *symbol_table = NULL;

void insert_symbol(char *name, char *category, char *data_type, char *desc) {
    struct Symbol *curr = symbol_table;
    while (curr) {
        if (strcmp(curr->name, name) == 0 && strcmp(curr->category, category) == 0) return; 
        curr = curr->next;
    }
    struct Symbol *new_node = (struct Symbol*)malloc(sizeof(struct Symbol));
    strcpy(new_node->name, name);
    strcpy(new_node->category, category);
    strcpy(new_node->data_type, data_type);
    strcpy(new_node->description, desc);
    new_node->first_line = line_no;
    new_node->next = symbol_table;
    symbol_table = new_node;
}

void print_symbol_table() {
    printf("\n%-15s | %-12s | %-10s | %-25s | %-5s\n", "Lexeme", "Category", "Type", "Description", "Line");
    printf("--------------------------------------------------------------------------------------------\n");
    struct Symbol *curr = symbol_table;
    while (curr) {
        printf("%-15s | %-12s | %-10s | %-25s | %-5d\n", curr->name, curr->category, curr->data_type, curr->description, curr->first_line);
        curr = curr->next;
    }
}
%}

DIGIT       [0-9]
LETTER      [a-zA-Z_]
ID          {LETTER}({LETTER}|{DIGIT})*
/* Fix: Improved float regex to catch malformed ones later */
FLOAT       {DIGIT}+"."{DIGIT}+
STRING      \"[^\"]*\"

%x COMMENT_STATE

%%

"/*"                { BEGIN(COMMENT_STATE); }
<COMMENT_STATE>"*/" { BEGIN(INITIAL); }
<COMMENT_STATE>\n   { line_no++; }
<COMMENT_STATE>.    { }
"//".*              { }

"int"|"float"|"void"|"string" {
    insert_symbol(yytext, "KEYWORD", "N/A", "Data Type");
    strcpy(last_type, yytext);
    needs_semi = 1; /* Expects a semicolon */
}

"return" { 
    insert_symbol(yytext, "KEYWORD", "N/A", "Control Flow"); 
    needs_semi = 1; /* Expects a semicolon */
}

"if"|"else"|"while" { 
    insert_symbol(yytext, "KEYWORD", "N/A", "Control Flow"); 
    needs_semi = 0; /* Block statements do not immediately need semicolons */
}

{ID} { 
    insert_symbol(yytext, "IDENTIFIER", last_type, "Variable/Function");
    needs_semi = 1;
}

{DIGIT}+            { insert_symbol(yytext, "CONSTANT", "int", "Integer Literal"); needs_semi = 1; }
{FLOAT}             { insert_symbol(yytext, "CONSTANT", "float", "Float Literal"); needs_semi = 1; }
{STRING}            { insert_symbol(yytext, "CONSTANT", "string", "String Literal"); needs_semi = 1; }

"="|"+"|"-"|"*"|"/"|"<"|">" { 
    insert_symbol(yytext, "OPERATOR", "N/A", "Operation"); 
    needs_semi = 1;
}

";" { 
    insert_symbol(yytext, "PUNCTUATION", "N/A", "Statement Terminator");
    strcpy(last_type, "UNKNOWN");
    needs_semi = 0; /* Semicolon found, reset flag */
}

"{"|"}" { 
    insert_symbol(yytext, "PUNCTUATION", "N/A", "Bracket");
    needs_semi = 0; /* Brackets resolve the need for a semicolon */
}

","|"("|")" { 
    insert_symbol(yytext, "PUNCTUATION", "N/A", "Separator/Bracket");
}

\n { 
    /* ERROR CHECK: If line ends and we still need a semicolon */
    if (needs_semi == 1) {
        printf("[LEXICAL ERROR] Line %d: Missing statement terminator (';')\n", line_no);
        needs_semi = 0; /* Reset flag so it doesn't loop infinitely */
    }
    line_no++; 
}

[ \t\r]+            { }

.                   { printf("[LEXICAL ERROR] Line %d: Illegal character '%s'\n", line_no, yytext); }

%%

int main(int argc, char **argv) {
    if (argc > 1) {
        yyin = fopen(argv[1], "r");
        if (!yyin) return 1;
    }
    yylex();
    
    /* Catch missing semicolon on the very last line if no newline is present */
    if (needs_semi == 1) {
        printf("[LEXICAL ERROR] Line %d: Missing statement terminator (';')\n", line_no);
    }

    printf("\n--- SYMBOL TABLE GENERATED BY FLUXLEX ---\n");
    print_symbol_table();
    return 0;
}
int yywrap() { return 1; }
